document.getElementById( 'prev-parser-content' ).value = (
"/*\n * Generated by PEG.js 0.10.0.\n *\n * http://pegjs.org/\n */\n(function() {\n  \"use strict\";\n\n  function peg$subclass(child, parent) {\n    function ctor() { this.constructor = child; }\n    ctor.prototype = parent.prototype;\n    child.prototype = new ctor();\n  }\n\n  function peg$SyntaxError(message, expected, found, location) {\n    this.message  = message;\n    this.expected = expected;\n    this.found    = found;\n    this.location = location;\n    this.name     = \"SyntaxError\";\n\n    if (typeof Error.captureStackTrace === \"function\") {\n      Error.captureStackTrace(this, peg$SyntaxError);\n    }\n  }\n\n  peg$subclass(peg$SyntaxError, Error);\n\n  peg$SyntaxError.buildMessage = function(expected, found) {\n    var DESCRIBE_EXPECTATION_FNS = {\n          literal: function(expectation) {\n            return \"\\\"\" + literalEscape(expectation.text) + \"\\\"\";\n          },\n\n          \"class\": function(expectation) {\n            var escapedParts = \"\",\n                i;\n\n            for (i = 0; i < expectation.parts.length; i++) {\n              escapedParts += expectation.parts[i] instanceof Array\n                ? classEscape(expectation.parts[i][0]) + \"-\" + classEscape(expectation.parts[i][1])\n                : classEscape(expectation.parts[i]);\n            }\n\n            return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts + \"]\";\n          },\n\n          any: function(expectation) {\n            return \"any character\";\n          },\n\n          end: function(expectation) {\n            return \"end of input\";\n          },\n\n          other: function(expectation) {\n            return expectation.description;\n          }\n        };\n\n    function hex(ch) {\n      return ch.charCodeAt(0).toString(16).toUpperCase();\n    }\n\n    function literalEscape(s) {\n      return s\n        .replace(/\\\\/g, '\\\\\\\\')\n        .replace(/\"/g,  '\\\\\"')\n        .replace(/\\0/g, '\\\\0')\n        .replace(/\\t/g, '\\\\t')\n        .replace(/\\n/g, '\\\\n')\n        .replace(/\\r/g, '\\\\r')\n        .replace(/[\\x00-\\x0F]/g,          function(ch) { return '\\\\x0' + hex(ch); })\n        .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return '\\\\x'  + hex(ch); });\n    }\n\n    function classEscape(s) {\n      return s\n        .replace(/\\\\/g, '\\\\\\\\')\n        .replace(/\\]/g, '\\\\]')\n        .replace(/\\^/g, '\\\\^')\n        .replace(/-/g,  '\\\\-')\n        .replace(/\\0/g, '\\\\0')\n        .replace(/\\t/g, '\\\\t')\n        .replace(/\\n/g, '\\\\n')\n        .replace(/\\r/g, '\\\\r')\n        .replace(/[\\x00-\\x0F]/g,          function(ch) { return '\\\\x0' + hex(ch); })\n        .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return '\\\\x'  + hex(ch); });\n    }\n\n    function describeExpectation(expectation) {\n      return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n    }\n\n    function describeExpected(expected) {\n      var descriptions = new Array(expected.length),\n          i, j;\n\n      for (i = 0; i < expected.length; i++) {\n        descriptions[i] = describeExpectation(expected[i]);\n      }\n\n      descriptions.sort();\n\n      if (descriptions.length > 0) {\n        for (i = 1, j = 1; i < descriptions.length; i++) {\n          if (descriptions[i - 1] !== descriptions[i]) {\n            descriptions[j] = descriptions[i];\n            j++;\n          }\n        }\n        descriptions.length = j;\n      }\n\n      switch (descriptions.length) {\n        case 1:\n          return descriptions[0];\n\n        case 2:\n          return descriptions[0] + \" or \" + descriptions[1];\n\n        default:\n          return descriptions.slice(0, -1).join(\", \")\n            + \", or \"\n            + descriptions[descriptions.length - 1];\n      }\n    }\n\n    function describeFound(found) {\n      return found ? \"\\\"\" + literalEscape(found) + \"\\\"\" : \"end of input\";\n    }\n\n    return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n  };\n\n  function peg$parse(input, options) {\n    options = options !== void 0 ? options : {};\n\n    var peg$FAILED = {},\n\n        peg$startRuleFunctions = { Block_List: peg$parseBlock_List },\n        peg$startRuleFunction  = peg$parseBlock_List,\n\n        peg$c0 = peg$anyExpectation(),\n        peg$c1 = function(pre, b, html) { /** <?php return array( $b, $html ); ?> **/ return [ b, html ] },\n        peg$c2 = function(pre, bs, post) { /** <?php return peg_join_blocks( $pre, $bs, $post ); ?> **/\n            return joinBlocks( pre, bs, post );\n          },\n        peg$c3 = \"<!--\",\n        peg$c4 = peg$literalExpectation(\"<!--\", false),\n        peg$c5 = \"wp:\",\n        peg$c6 = peg$literalExpectation(\"wp:\", false),\n        peg$c7 = function(blockName, a) {\n            /** <?php return $a; ?> **/\n            return a;\n          },\n        peg$c8 = \"/-->\",\n        peg$c9 = peg$literalExpectation(\"/-->\", false),\n        peg$c10 = function(blockName, attrs) {\n            /** <?php\n            return array(\n              'blockName'  => $blockName,\n              'attrs'      => $attrs,\n              'innerBlocks' => array(),\n              'innerHTML' => '',\n            );\n            ?> **/\n\n            return {\n              blockName: blockName,\n              attrs: attrs,\n              innerBlocks: [],\n              innerHTML: ''\n            };\n          },\n        peg$c11 = function(s, children, e) {\n            /** <?php\n            list( $innerHTML, $innerBlocks ) = peg_array_partition( $children, 'is_string' );\n\n            return array(\n              'blockName'  => $s['blockName'],\n              'attrs'      => $s['attrs'],\n              'innerBlocks'  => $innerBlocks,\n              'innerHTML'  => implode( '', $innerHTML ),\n            );\n            ?> **/\n\n            var innerContent = partition( function( a ) { return 'string' === typeof a }, children );\n            var innerHTML = innerContent[ 0 ];\n            var innerBlocks = innerContent[ 1 ];\n\n            return {\n              blockName: s.blockName,\n              attrs: s.attrs,\n              innerBlocks: innerBlocks,\n              innerHTML: innerHTML.join( '' )\n            };\n          },\n        peg$c12 = \"-->\",\n        peg$c13 = peg$literalExpectation(\"-->\", false),\n        peg$c14 = function(blockName, attrs) {\n            /** <?php\n            return array(\n              'blockName' => $blockName,\n              'attrs'     => $attrs,\n            );\n            ?> **/\n\n            return {\n              blockName: blockName,\n              attrs: attrs\n            };\n          },\n        peg$c15 = \"/wp:\",\n        peg$c16 = peg$literalExpectation(\"/wp:\", false),\n        peg$c17 = function(blockName) {\n            /** <?php\n            return array(\n              'blockName' => $blockName,\n            );\n            ?> **/\n\n            return {\n              blockName: blockName\n            };\n          },\n        peg$c18 = \"/\",\n        peg$c19 = peg$literalExpectation(\"/\", false),\n        peg$c20 = function(type) {\n            /** <?php return \"core/$type\"; ?> **/\n            return 'core/' + type;\n          },\n        peg$c21 = /^[a-z]/,\n        peg$c22 = peg$classExpectation([[\"a\", \"z\"]], false, false),\n        peg$c23 = /^[a-z0-9_\\-]/,\n        peg$c24 = peg$classExpectation([[\"a\", \"z\"], [\"0\", \"9\"], \"_\", \"-\"], false, false),\n        peg$c25 = \"{\",\n        peg$c26 = peg$literalExpectation(\"{\", false),\n        peg$c27 = \"}\",\n        peg$c28 = peg$literalExpectation(\"}\", false),\n        peg$c29 = \"\",\n        peg$c30 = function(attrs) {\n            /** <?php return json_decode( $attrs, true ); ?> **/\n            return maybeJSON( attrs );\n          },\n        peg$c31 = /^[ \\t\\r\\n]/,\n        peg$c32 = peg$classExpectation([\" \", \"\\t\", \"\\r\", \"\\n\"], false, false),\n\n        peg$currPos          = 0,\n        peg$savedPos         = 0,\n        peg$posDetailsCache  = [{ line: 1, column: 1 }],\n        peg$maxFailPos       = 0,\n        peg$maxFailExpected  = [],\n        peg$silentFails      = 0,\n\n        peg$resultsCache = {},\n\n        peg$result;\n\n    if (\"startRule\" in options) {\n      if (!(options.startRule in peg$startRuleFunctions)) {\n        throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n      }\n\n      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n    }\n\n    function text() {\n      return input.substring(peg$savedPos, peg$currPos);\n    }\n\n    function location() {\n      return peg$computeLocation(peg$savedPos, peg$currPos);\n    }\n\n    function expected(description, location) {\n      location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)\n\n      throw peg$buildStructuredError(\n        [peg$otherExpectation(description)],\n        input.substring(peg$savedPos, peg$currPos),\n        location\n      );\n    }\n\n    function error(message, location) {\n      location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)\n\n      throw peg$buildSimpleError(message, location);\n    }\n\n    function peg$literalExpectation(text, ignoreCase) {\n      return { type: \"literal\", text: text, ignoreCase: ignoreCase };\n    }\n\n    function peg$classExpectation(parts, inverted, ignoreCase) {\n      return { type: \"class\", parts: parts, inverted: inverted, ignoreCase: ignoreCase };\n    }\n\n    function peg$anyExpectation() {\n      return { type: \"any\" };\n    }\n\n    function peg$endExpectation() {\n      return { type: \"end\" };\n    }\n\n    function peg$otherExpectation(description) {\n      return { type: \"other\", description: description };\n    }\n\n    function peg$computePosDetails(pos) {\n      var details = peg$posDetailsCache[pos], p;\n\n      if (details) {\n        return details;\n      } else {\n        p = pos - 1;\n        while (!peg$posDetailsCache[p]) {\n          p--;\n        }\n\n        details = peg$posDetailsCache[p];\n        details = {\n          line:   details.line,\n          column: details.column\n        };\n\n        while (p < pos) {\n          if (input.charCodeAt(p) === 10) {\n            details.line++;\n            details.column = 1;\n          } else {\n            details.column++;\n          }\n\n          p++;\n        }\n\n        peg$posDetailsCache[pos] = details;\n        return details;\n      }\n    }\n\n    function peg$computeLocation(startPos, endPos) {\n      var startPosDetails = peg$computePosDetails(startPos),\n          endPosDetails   = peg$computePosDetails(endPos);\n\n      return {\n        start: {\n          offset: startPos,\n          line:   startPosDetails.line,\n          column: startPosDetails.column\n        },\n        end: {\n          offset: endPos,\n          line:   endPosDetails.line,\n          column: endPosDetails.column\n        }\n      };\n    }\n\n    function peg$fail(expected) {\n      if (peg$currPos < peg$maxFailPos) { return; }\n\n      if (peg$currPos > peg$maxFailPos) {\n        peg$maxFailPos = peg$currPos;\n        peg$maxFailExpected = [];\n      }\n\n      peg$maxFailExpected.push(expected);\n    }\n\n    function peg$buildSimpleError(message, location) {\n      return new peg$SyntaxError(message, null, null, location);\n    }\n\n    function peg$buildStructuredError(expected, found, location) {\n      return new peg$SyntaxError(\n        peg$SyntaxError.buildMessage(expected, found),\n        expected,\n        found,\n        location\n      );\n    }\n\n    function peg$parseBlock_List() {\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;\n\n      var key    = peg$currPos * 12 + 0,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$currPos;\n      peg$silentFails++;\n      s5 = peg$parseBlock();\n      peg$silentFails--;\n      if (s5 === peg$FAILED) {\n        s4 = void 0;\n      } else {\n        peg$currPos = s4;\n        s4 = peg$FAILED;\n      }\n      if (s4 !== peg$FAILED) {\n        if (input.length > peg$currPos) {\n          s5 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c0); }\n        }\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$currPos;\n        peg$silentFails++;\n        s5 = peg$parseBlock();\n        peg$silentFails--;\n        if (s5 === peg$FAILED) {\n          s4 = void 0;\n        } else {\n          peg$currPos = s4;\n          s4 = peg$FAILED;\n        }\n        if (s4 !== peg$FAILED) {\n          if (input.length > peg$currPos) {\n            s5 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c0); }\n          }\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = input.substring(s1, peg$currPos);\n      } else {\n        s1 = s2;\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$currPos;\n        s4 = peg$parseBlock();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$currPos;\n          s6 = [];\n          s7 = peg$currPos;\n          s8 = peg$currPos;\n          peg$silentFails++;\n          s9 = peg$parseBlock();\n          peg$silentFails--;\n          if (s9 === peg$FAILED) {\n            s8 = void 0;\n          } else {\n            peg$currPos = s8;\n            s8 = peg$FAILED;\n          }\n          if (s8 !== peg$FAILED) {\n            if (input.length > peg$currPos) {\n              s9 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s9 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c0); }\n            }\n            if (s9 !== peg$FAILED) {\n              s8 = [s8, s9];\n              s7 = s8;\n            } else {\n              peg$currPos = s7;\n              s7 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s7;\n            s7 = peg$FAILED;\n          }\n          while (s7 !== peg$FAILED) {\n            s6.push(s7);\n            s7 = peg$currPos;\n            s8 = peg$currPos;\n            peg$silentFails++;\n            s9 = peg$parseBlock();\n            peg$silentFails--;\n            if (s9 === peg$FAILED) {\n              s8 = void 0;\n            } else {\n              peg$currPos = s8;\n              s8 = peg$FAILED;\n            }\n            if (s8 !== peg$FAILED) {\n              if (input.length > peg$currPos) {\n                s9 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s9 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c0); }\n              }\n              if (s9 !== peg$FAILED) {\n                s8 = [s8, s9];\n                s7 = s8;\n              } else {\n                peg$currPos = s7;\n                s7 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s7;\n              s7 = peg$FAILED;\n            }\n          }\n          if (s6 !== peg$FAILED) {\n            s5 = input.substring(s5, peg$currPos);\n          } else {\n            s5 = s6;\n          }\n          if (s5 !== peg$FAILED) {\n            peg$savedPos = s3;\n            s4 = peg$c1(s1, s4, s5);\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$currPos;\n          s4 = peg$parseBlock();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$currPos;\n            s6 = [];\n            s7 = peg$currPos;\n            s8 = peg$currPos;\n            peg$silentFails++;\n            s9 = peg$parseBlock();\n            peg$silentFails--;\n            if (s9 === peg$FAILED) {\n              s8 = void 0;\n            } else {\n              peg$currPos = s8;\n              s8 = peg$FAILED;\n            }\n            if (s8 !== peg$FAILED) {\n              if (input.length > peg$currPos) {\n                s9 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s9 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c0); }\n              }\n              if (s9 !== peg$FAILED) {\n                s8 = [s8, s9];\n                s7 = s8;\n              } else {\n                peg$currPos = s7;\n                s7 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s7;\n              s7 = peg$FAILED;\n            }\n            while (s7 !== peg$FAILED) {\n              s6.push(s7);\n              s7 = peg$currPos;\n              s8 = peg$currPos;\n              peg$silentFails++;\n              s9 = peg$parseBlock();\n              peg$silentFails--;\n              if (s9 === peg$FAILED) {\n                s8 = void 0;\n              } else {\n                peg$currPos = s8;\n                s8 = peg$FAILED;\n              }\n              if (s8 !== peg$FAILED) {\n                if (input.length > peg$currPos) {\n                  s9 = input.charAt(peg$currPos);\n                  peg$currPos++;\n                } else {\n                  s9 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c0); }\n                }\n                if (s9 !== peg$FAILED) {\n                  s8 = [s8, s9];\n                  s7 = s8;\n                } else {\n                  peg$currPos = s7;\n                  s7 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s7;\n                s7 = peg$FAILED;\n              }\n            }\n            if (s6 !== peg$FAILED) {\n              s5 = input.substring(s5, peg$currPos);\n            } else {\n              s5 = s6;\n            }\n            if (s5 !== peg$FAILED) {\n              peg$savedPos = s3;\n              s4 = peg$c1(s1, s4, s5);\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$currPos;\n          s4 = [];\n          if (input.length > peg$currPos) {\n            s5 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c0); }\n          }\n          while (s5 !== peg$FAILED) {\n            s4.push(s5);\n            if (input.length > peg$currPos) {\n              s5 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c0); }\n            }\n          }\n          if (s4 !== peg$FAILED) {\n            s3 = input.substring(s3, peg$currPos);\n          } else {\n            s3 = s4;\n          }\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c2(s1, s2, s3);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseBlock() {\n      var s0;\n\n      var key    = peg$currPos * 12 + 1,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$parseBlock_Void();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseBlock_Balanced();\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseBlock_Void() {\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8;\n\n      var key    = peg$currPos * 12 + 2,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 4) === peg$c3) {\n        s1 = peg$c3;\n        peg$currPos += 4;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c4); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse__();\n        if (s2 !== peg$FAILED) {\n          if (input.substr(peg$currPos, 3) === peg$c5) {\n            s3 = peg$c5;\n            peg$currPos += 3;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c6); }\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parseBlock_Name();\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parse__();\n              if (s5 !== peg$FAILED) {\n                s6 = peg$currPos;\n                s7 = peg$parseBlock_Attributes();\n                if (s7 !== peg$FAILED) {\n                  s8 = peg$parse__();\n                  if (s8 !== peg$FAILED) {\n                    peg$savedPos = s6;\n                    s7 = peg$c7(s4, s7);\n                    s6 = s7;\n                  } else {\n                    peg$currPos = s6;\n                    s6 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s6;\n                  s6 = peg$FAILED;\n                }\n                if (s6 === peg$FAILED) {\n                  s6 = null;\n                }\n                if (s6 !== peg$FAILED) {\n                  if (input.substr(peg$currPos, 4) === peg$c8) {\n                    s7 = peg$c8;\n                    peg$currPos += 4;\n                  } else {\n                    s7 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c9); }\n                  }\n                  if (s7 !== peg$FAILED) {\n                    peg$savedPos = s0;\n                    s1 = peg$c10(s4, s6);\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseBlock_Balanced() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 12 + 3,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$parseBlock_Start();\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$parseBlock();\n        if (s3 === peg$FAILED) {\n          s3 = peg$currPos;\n          s4 = peg$currPos;\n          s5 = peg$currPos;\n          peg$silentFails++;\n          s6 = peg$parseBlock_End();\n          peg$silentFails--;\n          if (s6 === peg$FAILED) {\n            s5 = void 0;\n          } else {\n            peg$currPos = s5;\n            s5 = peg$FAILED;\n          }\n          if (s5 !== peg$FAILED) {\n            if (input.length > peg$currPos) {\n              s6 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s6 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c0); }\n            }\n            if (s6 !== peg$FAILED) {\n              s5 = [s5, s6];\n              s4 = s5;\n            } else {\n              peg$currPos = s4;\n              s4 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s4;\n            s4 = peg$FAILED;\n          }\n          if (s4 !== peg$FAILED) {\n            s3 = input.substring(s3, peg$currPos);\n          } else {\n            s3 = s4;\n          }\n        }\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$parseBlock();\n          if (s3 === peg$FAILED) {\n            s3 = peg$currPos;\n            s4 = peg$currPos;\n            s5 = peg$currPos;\n            peg$silentFails++;\n            s6 = peg$parseBlock_End();\n            peg$silentFails--;\n            if (s6 === peg$FAILED) {\n              s5 = void 0;\n            } else {\n              peg$currPos = s5;\n              s5 = peg$FAILED;\n            }\n            if (s5 !== peg$FAILED) {\n              if (input.length > peg$currPos) {\n                s6 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s6 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c0); }\n              }\n              if (s6 !== peg$FAILED) {\n                s5 = [s5, s6];\n                s4 = s5;\n              } else {\n                peg$currPos = s4;\n                s4 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s4;\n              s4 = peg$FAILED;\n            }\n            if (s4 !== peg$FAILED) {\n              s3 = input.substring(s3, peg$currPos);\n            } else {\n              s3 = s4;\n            }\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseBlock_End();\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c11(s1, s2, s3);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseBlock_Start() {\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8;\n\n      var key    = peg$currPos * 12 + 4,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 4) === peg$c3) {\n        s1 = peg$c3;\n        peg$currPos += 4;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c4); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse__();\n        if (s2 !== peg$FAILED) {\n          if (input.substr(peg$currPos, 3) === peg$c5) {\n            s3 = peg$c5;\n            peg$currPos += 3;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c6); }\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parseBlock_Name();\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parse__();\n              if (s5 !== peg$FAILED) {\n                s6 = peg$currPos;\n                s7 = peg$parseBlock_Attributes();\n                if (s7 !== peg$FAILED) {\n                  s8 = peg$parse__();\n                  if (s8 !== peg$FAILED) {\n                    peg$savedPos = s6;\n                    s7 = peg$c7(s4, s7);\n                    s6 = s7;\n                  } else {\n                    peg$currPos = s6;\n                    s6 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s6;\n                  s6 = peg$FAILED;\n                }\n                if (s6 === peg$FAILED) {\n                  s6 = null;\n                }\n                if (s6 !== peg$FAILED) {\n                  if (input.substr(peg$currPos, 3) === peg$c12) {\n                    s7 = peg$c12;\n                    peg$currPos += 3;\n                  } else {\n                    s7 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c13); }\n                  }\n                  if (s7 !== peg$FAILED) {\n                    peg$savedPos = s0;\n                    s1 = peg$c14(s4, s6);\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseBlock_End() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      var key    = peg$currPos * 12 + 5,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 4) === peg$c3) {\n        s1 = peg$c3;\n        peg$currPos += 4;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c4); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse__();\n        if (s2 !== peg$FAILED) {\n          if (input.substr(peg$currPos, 4) === peg$c15) {\n            s3 = peg$c15;\n            peg$currPos += 4;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c16); }\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parseBlock_Name();\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parse__();\n              if (s5 !== peg$FAILED) {\n                if (input.substr(peg$currPos, 3) === peg$c12) {\n                  s6 = peg$c12;\n                  peg$currPos += 3;\n                } else {\n                  s6 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c13); }\n                }\n                if (s6 !== peg$FAILED) {\n                  peg$savedPos = s0;\n                  s1 = peg$c17(s4);\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseBlock_Name() {\n      var s0;\n\n      var key    = peg$currPos * 12 + 6,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$parseNamespaced_Block_Name();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseCore_Block_Name();\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseNamespaced_Block_Name() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 12 + 7,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseBlock_Name_Part();\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 47) {\n          s3 = peg$c18;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c19); }\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseBlock_Name_Part();\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        s0 = input.substring(s0, peg$currPos);\n      } else {\n        s0 = s1;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseCore_Block_Name() {\n      var s0, s1, s2;\n\n      var key    = peg$currPos * 12 + 8,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseBlock_Name_Part();\n      if (s2 !== peg$FAILED) {\n        s1 = input.substring(s1, peg$currPos);\n      } else {\n        s1 = s2;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c20(s1);\n      }\n      s0 = s1;\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseBlock_Name_Part() {\n      var s0, s1, s2, s3, s4;\n\n      var key    = peg$currPos * 12 + 9,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      if (peg$c21.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c22); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = [];\n        if (peg$c23.test(input.charAt(peg$currPos))) {\n          s4 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s4 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c24); }\n        }\n        while (s4 !== peg$FAILED) {\n          s3.push(s4);\n          if (peg$c23.test(input.charAt(peg$currPos))) {\n            s4 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c24); }\n          }\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        s0 = input.substring(s0, peg$currPos);\n      } else {\n        s0 = s1;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parseBlock_Attributes() {\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12;\n\n      var key    = peg$currPos * 12 + 10,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 123) {\n        s3 = peg$c25;\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c26); }\n      }\n      if (s3 !== peg$FAILED) {\n        s4 = [];\n        s5 = peg$currPos;\n        s6 = peg$currPos;\n        peg$silentFails++;\n        s7 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 125) {\n          s8 = peg$c27;\n          peg$currPos++;\n        } else {\n          s8 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c28); }\n        }\n        if (s8 !== peg$FAILED) {\n          s9 = peg$parse__();\n          if (s9 !== peg$FAILED) {\n            s10 = peg$c29;\n            if (s10 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 47) {\n                s11 = peg$c18;\n                peg$currPos++;\n              } else {\n                s11 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c19); }\n              }\n              if (s11 === peg$FAILED) {\n                s11 = null;\n              }\n              if (s11 !== peg$FAILED) {\n                if (input.substr(peg$currPos, 3) === peg$c12) {\n                  s12 = peg$c12;\n                  peg$currPos += 3;\n                } else {\n                  s12 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c13); }\n                }\n                if (s12 !== peg$FAILED) {\n                  s8 = [s8, s9, s10, s11, s12];\n                  s7 = s8;\n                } else {\n                  peg$currPos = s7;\n                  s7 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s7;\n                s7 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s7;\n              s7 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s7;\n            s7 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s7;\n          s7 = peg$FAILED;\n        }\n        peg$silentFails--;\n        if (s7 === peg$FAILED) {\n          s6 = void 0;\n        } else {\n          peg$currPos = s6;\n          s6 = peg$FAILED;\n        }\n        if (s6 !== peg$FAILED) {\n          if (input.length > peg$currPos) {\n            s7 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s7 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c0); }\n          }\n          if (s7 !== peg$FAILED) {\n            s6 = [s6, s7];\n            s5 = s6;\n          } else {\n            peg$currPos = s5;\n            s5 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s5;\n          s5 = peg$FAILED;\n        }\n        while (s5 !== peg$FAILED) {\n          s4.push(s5);\n          s5 = peg$currPos;\n          s6 = peg$currPos;\n          peg$silentFails++;\n          s7 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 125) {\n            s8 = peg$c27;\n            peg$currPos++;\n          } else {\n            s8 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c28); }\n          }\n          if (s8 !== peg$FAILED) {\n            s9 = peg$parse__();\n            if (s9 !== peg$FAILED) {\n              s10 = peg$c29;\n              if (s10 !== peg$FAILED) {\n                if (input.charCodeAt(peg$currPos) === 47) {\n                  s11 = peg$c18;\n                  peg$currPos++;\n                } else {\n                  s11 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c19); }\n                }\n                if (s11 === peg$FAILED) {\n                  s11 = null;\n                }\n                if (s11 !== peg$FAILED) {\n                  if (input.substr(peg$currPos, 3) === peg$c12) {\n                    s12 = peg$c12;\n                    peg$currPos += 3;\n                  } else {\n                    s12 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c13); }\n                  }\n                  if (s12 !== peg$FAILED) {\n                    s8 = [s8, s9, s10, s11, s12];\n                    s7 = s8;\n                  } else {\n                    peg$currPos = s7;\n                    s7 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s7;\n                  s7 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s7;\n                s7 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s7;\n              s7 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s7;\n            s7 = peg$FAILED;\n          }\n          peg$silentFails--;\n          if (s7 === peg$FAILED) {\n            s6 = void 0;\n          } else {\n            peg$currPos = s6;\n            s6 = peg$FAILED;\n          }\n          if (s6 !== peg$FAILED) {\n            if (input.length > peg$currPos) {\n              s7 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s7 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c0); }\n            }\n            if (s7 !== peg$FAILED) {\n              s6 = [s6, s7];\n              s5 = s6;\n            } else {\n              peg$currPos = s5;\n              s5 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s5;\n            s5 = peg$FAILED;\n          }\n        }\n        if (s4 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 125) {\n            s5 = peg$c27;\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c28); }\n          }\n          if (s5 !== peg$FAILED) {\n            s3 = [s3, s4, s5];\n            s2 = s3;\n          } else {\n            peg$currPos = s2;\n            s2 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = input.substring(s1, peg$currPos);\n      } else {\n        s1 = s2;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c30(s1);\n      }\n      s0 = s1;\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n    function peg$parse__() {\n      var s0, s1;\n\n      var key    = peg$currPos * 12 + 11,\n          cached = peg$resultsCache[key];\n\n      if (cached) {\n        peg$currPos = cached.nextPos;\n\n        return cached.result;\n      }\n\n      s0 = [];\n      if (peg$c31.test(input.charAt(peg$currPos))) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c32); }\n      }\n      if (s1 !== peg$FAILED) {\n        while (s1 !== peg$FAILED) {\n          s0.push(s1);\n          if (peg$c31.test(input.charAt(peg$currPos))) {\n            s1 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c32); }\n          }\n        }\n      } else {\n        s0 = peg$FAILED;\n      }\n\n      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };\n\n      return s0;\n    }\n\n\n\n    /*\n     *\n     *    _____       _             _\n     *   / ____|     | |           | |\n     *  | |  __ _   _| |_ ___ _ __ | |__   ___ _ __ __ _\n     *  | | |_ | | | | __/ _ \\ '_ \\| '_ \\ / _ \\ '__/ _` |\n     *  | |__| | |_| | ||  __/ | | | |_) |  __/ | | (_| |\n     *   \\_____|\\__,_|\\__\\___|_| |_|_.__/ \\___|_|  \\__, |\n     *                                              __/ |\n     *                  GRAMMAR                    |___/\n     *\n     *\n     * Welcome to the grammar file for Gutenberg posts!\n     *\n     * Please don't be distracted by the functions at the top\n     * here - they're just helpers for the grammar below. We\n     * try to keep them as minimal and simple as possible,\n     * but the parser generator forces us to declare them at\n     * the beginning of the file.\n     *\n     * What follows is the official specification grammar for\n     * documents created or edited in Gutenberg. It starts at\n     * the top-level rule `Block_List`\n     *\n     * The grammar is defined by a series of _rules_ and ways\n     * to return matches on those rules. It's a _PEG_, a\n     * parsing expression grammar, which simply means that for\n     * each of our rules we have a set of sub-rules to match\n     * on and the generated parser will try them in order\n     * until it finds the first match.\n     *\n     * This grammar is a _specification_ (with as little actual\n     * code as we can get away with) which is used by the\n     * parser generator to generate the actual _parser_ which\n     * is used by Gutenberg. We generate two parsers: one in\n     * JavaScript for use the browser and one in PHP for\n     * WordPress itself. PEG parser generators are available\n     * in many languages, though different libraries may require\n     * some translation of this grammar into their syntax.\n     *\n     * For more information:\n     * @see https://pegjs.org\n     * @see https://en.wikipedia.org/wiki/Parsing_expression_grammar\n     *\n     */\n\n    /** <?php\n    // The `maybeJSON` function is not needed in PHP because its return semantics\n    // are the same as `json_decode`\n\n    // array arguments are backwards because of PHP\n    if ( ! function_exists( 'peg_array_partition' ) ) {\n        function peg_array_partition( $array, $predicate ) {\n            $truthy = array();\n            $falsey = array();\n\n            foreach ( $array as $item ) {\n                call_user_func( $predicate, $item )\n                    ? $truthy[] = $item\n                    : $falsey[] = $item;\n            }\n\n            return array( $truthy, $falsey );\n        }\n    }\n\n    if ( ! function_exists( 'peg_join_blocks' ) ) {\n        function peg_join_blocks( $pre, $tokens, $post ) {\n            $blocks = array();\n\n            if ( ! empty( $pre ) ) {\n                $blocks[] = array( 'attrs' => array(), 'innerHTML' => $pre );\n            }\n\n            foreach ( $tokens as $token ) {\n                list( $token, $html ) = $token;\n\n                $blocks[] = $token;\n\n                if ( ! empty( $html ) ) {\n                    $blocks[] = array( 'attrs' => array(), 'innerHTML' => $html );\n                }\n            }\n\n            if ( ! empty( $post ) ) {\n                $blocks[] = array( 'attrs' => array(), 'innerHTML' => $post );\n            }\n\n            return $blocks;\n        }\n    }\n\n    ?> **/\n\n    function freeform( s ) {\n        return s.length && {\n            attrs: {},\n            innerHTML: s\n        };\n    }\n\n    function joinBlocks( pre, tokens, post ) {\n        var blocks = [], i, l, html, item, token;\n\n        if ( pre.length ) {\n            blocks.push( freeform( pre ) );\n        }\n\n        for ( i = 0, l = tokens.length; i < l; i++ ) {\n            item = tokens[ i ];\n            token = item[ 0 ];\n            html = item[ 1 ];\n\n            blocks.push( token );\n            if ( html.length ) {\n                blocks.push( freeform( html ) );\n            }\n        }\n\n        if ( post.length ) {\n            blocks.push( freeform( post ) );\n        }\n\n        return blocks;\n    }\n\n    function maybeJSON( s ) {\n        try {\n            return JSON.parse( s );\n        } catch (e) {\n            return null;\n        }\n    }\n\n    function partition( predicate, list ) {\n        var i, l, item;\n        var truthy = [];\n        var falsey = [];\n\n        // nod to performance over a simpler reduce\n        // and clone model we could have taken here\n        for ( i = 0, l = list.length; i < l; i++ ) {\n            item = list[ i ];\n\n            predicate( item )\n                ? truthy.push( item )\n                : falsey.push( item )\n        };\n\n        return [ truthy, falsey ];\n    }\n\n\n\n    peg$result = peg$startRuleFunction();\n\n    if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n      return peg$result;\n    } else {\n      if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n        peg$fail(peg$endExpectation());\n      }\n\n      throw peg$buildStructuredError(\n        peg$maxFailExpected,\n        peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,\n        peg$maxFailPos < input.length\n          ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)\n          : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)\n      );\n    }\n  }\n\n  return peg$parse;\n});\n"
);

document.getElementById( 'next-parser-content' ).value = (
    "/*\n * Generated by PEG.js 0.10.0.\n *\n * http://pegjs.org/\n */\n(function() {\n  \"use strict\";\n\n  function peg$subclass(child, parent) {\n    function ctor() { this.constructor = child; }\n    ctor.prototype = parent.prototype;\n    child.prototype = new ctor();\n  }\n\n  function peg$SyntaxError(message, expected, found, location) {\n    this.message  = message;\n    this.expected = expected;\n    this.found    = found;\n    this.location = location;\n    this.name     = \"SyntaxError\";\n\n    if (typeof Error.captureStackTrace === \"function\") {\n      Error.captureStackTrace(this, peg$SyntaxError);\n    }\n  }\n\n  peg$subclass(peg$SyntaxError, Error);\n\n  peg$SyntaxError.buildMessage = function(expected, found) {\n    var DESCRIBE_EXPECTATION_FNS = {\n          literal: function(expectation) {\n            return \"\\\"\" + literalEscape(expectation.text) + \"\\\"\";\n          },\n\n          \"class\": function(expectation) {\n            var escapedParts = \"\",\n                i;\n\n            for (i = 0; i < expectation.parts.length; i++) {\n              escapedParts += expectation.parts[i] instanceof Array\n                ? classEscape(expectation.parts[i][0]) + \"-\" + classEscape(expectation.parts[i][1])\n                : classEscape(expectation.parts[i]);\n            }\n\n            return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts + \"]\";\n          },\n\n          any: function(expectation) {\n            return \"any character\";\n          },\n\n          end: function(expectation) {\n            return \"end of input\";\n          },\n\n          other: function(expectation) {\n            return expectation.description;\n          }\n        };\n\n    function hex(ch) {\n      return ch.charCodeAt(0).toString(16).toUpperCase();\n    }\n\n    function literalEscape(s) {\n      return s\n        .replace(/\\\\/g, '\\\\\\\\')\n        .replace(/\"/g,  '\\\\\"')\n        .replace(/\\0/g, '\\\\0')\n        .replace(/\\t/g, '\\\\t')\n        .replace(/\\n/g, '\\\\n')\n        .replace(/\\r/g, '\\\\r')\n        .replace(/[\\x00-\\x0F]/g,          function(ch) { return '\\\\x0' + hex(ch); })\n        .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return '\\\\x'  + hex(ch); });\n    }\n\n    function classEscape(s) {\n      return s\n        .replace(/\\\\/g, '\\\\\\\\')\n        .replace(/\\]/g, '\\\\]')\n        .replace(/\\^/g, '\\\\^')\n        .replace(/-/g,  '\\\\-')\n        .replace(/\\0/g, '\\\\0')\n        .replace(/\\t/g, '\\\\t')\n        .replace(/\\n/g, '\\\\n')\n        .replace(/\\r/g, '\\\\r')\n        .replace(/[\\x00-\\x0F]/g,          function(ch) { return '\\\\x0' + hex(ch); })\n        .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return '\\\\x'  + hex(ch); });\n    }\n\n    function describeExpectation(expectation) {\n      return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n    }\n\n    function describeExpected(expected) {\n      var descriptions = new Array(expected.length),\n          i, j;\n\n      for (i = 0; i < expected.length; i++) {\n        descriptions[i] = describeExpectation(expected[i]);\n      }\n\n      descriptions.sort();\n\n      if (descriptions.length > 0) {\n        for (i = 1, j = 1; i < descriptions.length; i++) {\n          if (descriptions[i - 1] !== descriptions[i]) {\n            descriptions[j] = descriptions[i];\n            j++;\n          }\n        }\n        descriptions.length = j;\n      }\n\n      switch (descriptions.length) {\n        case 1:\n          return descriptions[0];\n\n        case 2:\n          return descriptions[0] + \" or \" + descriptions[1];\n\n        default:\n          return descriptions.slice(0, -1).join(\", \")\n            + \", or \"\n            + descriptions[descriptions.length - 1];\n      }\n    }\n\n    function describeFound(found) {\n      return found ? \"\\\"\" + literalEscape(found) + \"\\\"\" : \"end of input\";\n    }\n\n    return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n  };\n\n  function peg$parse(input, options) {\n    options = options !== void 0 ? options : {};\n\n    var peg$FAILED = {},\n\n        peg$startRuleFunctions = { Block_List: peg$parseBlock_List },\n        peg$startRuleFunction  = peg$parseBlock_List,\n\n        peg$c0 = peg$anyExpectation(),\n        peg$c1 = function(pre, b, html) { /** <?php return array( $b, $html ); ?> **/ return [ b, html ] },\n        peg$c2 = function(pre, bs, post) { /** <?php return peg_join_blocks( $pre, $bs, $post ); ?> **/\n            return joinBlocks( pre, bs, post );\n          },\n        peg$c3 = \"<!--\",\n        peg$c4 = peg$literalExpectation(\"<!--\", false),\n        peg$c5 = \"wp:\",\n        peg$c6 = peg$literalExpectation(\"wp:\", false),\n        peg$c7 = function(blockName, a) {\n            /** <?php return $a; ?> **/\n            return a;\n          },\n        peg$c8 = \"/-->\",\n        peg$c9 = peg$literalExpectation(\"/-->\", false),\n        peg$c10 = function(blockName, attrs) {\n            /** <?php\n            return array(\n              'blockName'  => $blockName,\n              'attrs'      => $attrs,\n              'innerBlocks' => array(),\n              'innerHTML' => '',\n            );\n            ?> **/\n\n            return {\n              blockName: blockName,\n              attrs: attrs,\n              innerBlocks: [],\n              innerHTML: ''\n            };\n          },\n        peg$c11 = function(s, children, e) {\n            /** <?php\n            list( $innerHTML, $innerBlocks ) = peg_array_partition( $children, 'is_string' );\n\n            return array(\n              'blockName'  => $s['blockName'],\n              'attrs'      => $s['attrs'],\n              'innerBlocks'  => $innerBlocks,\n              'innerHTML'  => implode( '', $innerHTML ),\n            );\n            ?> **/\n\n            var innerContent = partition( function( a ) { return 'string' === typeof a }, children );\n            var innerHTML = innerContent[ 0 ];\n            var innerBlocks = innerContent[ 1 ];\n\n            return {\n              blockName: s.blockName,\n              attrs: s.attrs,\n              innerBlocks: innerBlocks,\n              innerHTML: innerHTML.join( '' )\n            };\n          },\n        peg$c12 = \"-->\",\n        peg$c13 = peg$literalExpectation(\"-->\", false),\n        peg$c14 = function(blockName, attrs) {\n            /** <?php\n            return array(\n              'blockName' => $blockName,\n              'attrs'     => $attrs,\n            );\n            ?> **/\n\n            return {\n              blockName: blockName,\n              attrs: attrs\n            };\n          },\n        peg$c15 = \"/wp:\",\n        peg$c16 = peg$literalExpectation(\"/wp:\", false),\n        peg$c17 = function(blockName) {\n            /** <?php\n            return array(\n              'blockName' => $blockName,\n            );\n            ?> **/\n\n            return {\n              blockName: blockName\n            };\n          },\n        peg$c18 = \"/\",\n        peg$c19 = peg$literalExpectation(\"/\", false),\n        peg$c20 = function(type) {\n            /** <?php return \"core/$type\"; ?> **/\n            return 'core/' + type;\n          },\n        peg$c21 = /^[a-z]/,\n        peg$c22 = peg$classExpectation([[\"a\", \"z\"]], false, false),\n        peg$c23 = /^[a-z0-9_\\-]/,\n        peg$c24 = peg$classExpectation([[\"a\", \"z\"], [\"0\", \"9\"], \"_\", \"-\"], false, false),\n        peg$c25 = \"{\",\n        peg$c26 = peg$literalExpectation(\"{\", false),\n        peg$c27 = \"}\",\n        peg$c28 = peg$literalExpectation(\"}\", false),\n        peg$c29 = \"\",\n        peg$c30 = function(attrs) {\n            /** <?php return json_decode( $attrs, true ); ?> **/\n            return maybeJSON( attrs );\n          },\n        peg$c31 = /^[ \\t\\r\\n]/,\n        peg$c32 = peg$classExpectation([\" \", \"\\t\", \"\\r\", \"\\n\"], false, false),\n\n        peg$currPos          = 0,\n        peg$savedPos         = 0,\n        peg$posDetailsCache  = [{ line: 1, column: 1 }],\n        peg$maxFailPos       = 0,\n        peg$maxFailExpected  = [],\n        peg$silentFails      = 0,\n\n        peg$result;\n\n    if (\"startRule\" in options) {\n      if (!(options.startRule in peg$startRuleFunctions)) {\n        throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n      }\n\n      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n    }\n\n    function text() {\n      return input.substring(peg$savedPos, peg$currPos);\n    }\n\n    function location() {\n      return peg$computeLocation(peg$savedPos, peg$currPos);\n    }\n\n    function expected(description, location) {\n      location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)\n\n      throw peg$buildStructuredError(\n        [peg$otherExpectation(description)],\n        input.substring(peg$savedPos, peg$currPos),\n        location\n      );\n    }\n\n    function error(message, location) {\n      location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)\n\n      throw peg$buildSimpleError(message, location);\n    }\n\n    function peg$literalExpectation(text, ignoreCase) {\n      return { type: \"literal\", text: text, ignoreCase: ignoreCase };\n    }\n\n    function peg$classExpectation(parts, inverted, ignoreCase) {\n      return { type: \"class\", parts: parts, inverted: inverted, ignoreCase: ignoreCase };\n    }\n\n    function peg$anyExpectation() {\n      return { type: \"any\" };\n    }\n\n    function peg$endExpectation() {\n      return { type: \"end\" };\n    }\n\n    function peg$otherExpectation(description) {\n      return { type: \"other\", description: description };\n    }\n\n    function peg$computePosDetails(pos) {\n      var details = peg$posDetailsCache[pos], p;\n\n      if (details) {\n        return details;\n      } else {\n        p = pos - 1;\n        while (!peg$posDetailsCache[p]) {\n          p--;\n        }\n\n        details = peg$posDetailsCache[p];\n        details = {\n          line:   details.line,\n          column: details.column\n        };\n\n        while (p < pos) {\n          if (input.charCodeAt(p) === 10) {\n            details.line++;\n            details.column = 1;\n          } else {\n            details.column++;\n          }\n\n          p++;\n        }\n\n        peg$posDetailsCache[pos] = details;\n        return details;\n      }\n    }\n\n    function peg$computeLocation(startPos, endPos) {\n      var startPosDetails = peg$computePosDetails(startPos),\n          endPosDetails   = peg$computePosDetails(endPos);\n\n      return {\n        start: {\n          offset: startPos,\n          line:   startPosDetails.line,\n          column: startPosDetails.column\n        },\n        end: {\n          offset: endPos,\n          line:   endPosDetails.line,\n          column: endPosDetails.column\n        }\n      };\n    }\n\n    function peg$fail(expected) {\n      if (peg$currPos < peg$maxFailPos) { return; }\n\n      if (peg$currPos > peg$maxFailPos) {\n        peg$maxFailPos = peg$currPos;\n        peg$maxFailExpected = [];\n      }\n\n      peg$maxFailExpected.push(expected);\n    }\n\n    function peg$buildSimpleError(message, location) {\n      return new peg$SyntaxError(message, null, null, location);\n    }\n\n    function peg$buildStructuredError(expected, found, location) {\n      return new peg$SyntaxError(\n        peg$SyntaxError.buildMessage(expected, found),\n        expected,\n        found,\n        location\n      );\n    }\n\n    function peg$parseBlock_List() {\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$currPos;\n      peg$silentFails++;\n      s5 = peg$parseBlock();\n      peg$silentFails--;\n      if (s5 === peg$FAILED) {\n        s4 = void 0;\n      } else {\n        peg$currPos = s4;\n        s4 = peg$FAILED;\n      }\n      if (s4 !== peg$FAILED) {\n        if (input.length > peg$currPos) {\n          s5 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c0); }\n        }\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$currPos;\n        peg$silentFails++;\n        s5 = peg$parseBlock();\n        peg$silentFails--;\n        if (s5 === peg$FAILED) {\n          s4 = void 0;\n        } else {\n          peg$currPos = s4;\n          s4 = peg$FAILED;\n        }\n        if (s4 !== peg$FAILED) {\n          if (input.length > peg$currPos) {\n            s5 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c0); }\n          }\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = input.substring(s1, peg$currPos);\n      } else {\n        s1 = s2;\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$currPos;\n        s4 = peg$parseBlock();\n        if (s4 !== peg$FAILED) {\n          s5 = peg$currPos;\n          s6 = [];\n          s7 = peg$currPos;\n          s8 = peg$currPos;\n          peg$silentFails++;\n          s9 = peg$parseBlock();\n          peg$silentFails--;\n          if (s9 === peg$FAILED) {\n            s8 = void 0;\n          } else {\n            peg$currPos = s8;\n            s8 = peg$FAILED;\n          }\n          if (s8 !== peg$FAILED) {\n            if (input.length > peg$currPos) {\n              s9 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s9 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c0); }\n            }\n            if (s9 !== peg$FAILED) {\n              s8 = [s8, s9];\n              s7 = s8;\n            } else {\n              peg$currPos = s7;\n              s7 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s7;\n            s7 = peg$FAILED;\n          }\n          while (s7 !== peg$FAILED) {\n            s6.push(s7);\n            s7 = peg$currPos;\n            s8 = peg$currPos;\n            peg$silentFails++;\n            s9 = peg$parseBlock();\n            peg$silentFails--;\n            if (s9 === peg$FAILED) {\n              s8 = void 0;\n            } else {\n              peg$currPos = s8;\n              s8 = peg$FAILED;\n            }\n            if (s8 !== peg$FAILED) {\n              if (input.length > peg$currPos) {\n                s9 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s9 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c0); }\n              }\n              if (s9 !== peg$FAILED) {\n                s8 = [s8, s9];\n                s7 = s8;\n              } else {\n                peg$currPos = s7;\n                s7 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s7;\n              s7 = peg$FAILED;\n            }\n          }\n          if (s6 !== peg$FAILED) {\n            s5 = input.substring(s5, peg$currPos);\n          } else {\n            s5 = s6;\n          }\n          if (s5 !== peg$FAILED) {\n            peg$savedPos = s3;\n            s4 = peg$c1(s1, s4, s5);\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$currPos;\n          s4 = peg$parseBlock();\n          if (s4 !== peg$FAILED) {\n            s5 = peg$currPos;\n            s6 = [];\n            s7 = peg$currPos;\n            s8 = peg$currPos;\n            peg$silentFails++;\n            s9 = peg$parseBlock();\n            peg$silentFails--;\n            if (s9 === peg$FAILED) {\n              s8 = void 0;\n            } else {\n              peg$currPos = s8;\n              s8 = peg$FAILED;\n            }\n            if (s8 !== peg$FAILED) {\n              if (input.length > peg$currPos) {\n                s9 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s9 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c0); }\n              }\n              if (s9 !== peg$FAILED) {\n                s8 = [s8, s9];\n                s7 = s8;\n              } else {\n                peg$currPos = s7;\n                s7 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s7;\n              s7 = peg$FAILED;\n            }\n            while (s7 !== peg$FAILED) {\n              s6.push(s7);\n              s7 = peg$currPos;\n              s8 = peg$currPos;\n              peg$silentFails++;\n              s9 = peg$parseBlock();\n              peg$silentFails--;\n              if (s9 === peg$FAILED) {\n                s8 = void 0;\n              } else {\n                peg$currPos = s8;\n                s8 = peg$FAILED;\n              }\n              if (s8 !== peg$FAILED) {\n                if (input.length > peg$currPos) {\n                  s9 = input.charAt(peg$currPos);\n                  peg$currPos++;\n                } else {\n                  s9 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c0); }\n                }\n                if (s9 !== peg$FAILED) {\n                  s8 = [s8, s9];\n                  s7 = s8;\n                } else {\n                  peg$currPos = s7;\n                  s7 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s7;\n                s7 = peg$FAILED;\n              }\n            }\n            if (s6 !== peg$FAILED) {\n              s5 = input.substring(s5, peg$currPos);\n            } else {\n              s5 = s6;\n            }\n            if (s5 !== peg$FAILED) {\n              peg$savedPos = s3;\n              s4 = peg$c1(s1, s4, s5);\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$currPos;\n          s4 = [];\n          if (input.length > peg$currPos) {\n            s5 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c0); }\n          }\n          while (s5 !== peg$FAILED) {\n            s4.push(s5);\n            if (input.length > peg$currPos) {\n              s5 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s5 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c0); }\n            }\n          }\n          if (s4 !== peg$FAILED) {\n            s3 = input.substring(s3, peg$currPos);\n          } else {\n            s3 = s4;\n          }\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c2(s1, s2, s3);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseBlock() {\n      var s0;\n\n      s0 = peg$parseBlock_Void();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseBlock_Balanced();\n      }\n\n      return s0;\n    }\n\n    function peg$parseBlock_Void() {\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8;\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 4) === peg$c3) {\n        s1 = peg$c3;\n        peg$currPos += 4;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c4); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse__();\n        if (s2 !== peg$FAILED) {\n          if (input.substr(peg$currPos, 3) === peg$c5) {\n            s3 = peg$c5;\n            peg$currPos += 3;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c6); }\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parseBlock_Name();\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parse__();\n              if (s5 !== peg$FAILED) {\n                s6 = peg$currPos;\n                s7 = peg$parseBlock_Attributes();\n                if (s7 !== peg$FAILED) {\n                  s8 = peg$parse__();\n                  if (s8 !== peg$FAILED) {\n                    peg$savedPos = s6;\n                    s7 = peg$c7(s4, s7);\n                    s6 = s7;\n                  } else {\n                    peg$currPos = s6;\n                    s6 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s6;\n                  s6 = peg$FAILED;\n                }\n                if (s6 === peg$FAILED) {\n                  s6 = null;\n                }\n                if (s6 !== peg$FAILED) {\n                  if (input.substr(peg$currPos, 4) === peg$c8) {\n                    s7 = peg$c8;\n                    peg$currPos += 4;\n                  } else {\n                    s7 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c9); }\n                  }\n                  if (s7 !== peg$FAILED) {\n                    peg$savedPos = s0;\n                    s1 = peg$c10(s4, s6);\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseBlock_Balanced() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      s0 = peg$currPos;\n      s1 = peg$parseBlock_Start();\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$parseBlock();\n        if (s3 === peg$FAILED) {\n          s3 = peg$currPos;\n          s4 = peg$currPos;\n          s5 = peg$currPos;\n          peg$silentFails++;\n          s6 = peg$parseBlock_End();\n          peg$silentFails--;\n          if (s6 === peg$FAILED) {\n            s5 = void 0;\n          } else {\n            peg$currPos = s5;\n            s5 = peg$FAILED;\n          }\n          if (s5 !== peg$FAILED) {\n            if (input.length > peg$currPos) {\n              s6 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s6 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c0); }\n            }\n            if (s6 !== peg$FAILED) {\n              s5 = [s5, s6];\n              s4 = s5;\n            } else {\n              peg$currPos = s4;\n              s4 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s4;\n            s4 = peg$FAILED;\n          }\n          if (s4 !== peg$FAILED) {\n            s3 = input.substring(s3, peg$currPos);\n          } else {\n            s3 = s4;\n          }\n        }\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$parseBlock();\n          if (s3 === peg$FAILED) {\n            s3 = peg$currPos;\n            s4 = peg$currPos;\n            s5 = peg$currPos;\n            peg$silentFails++;\n            s6 = peg$parseBlock_End();\n            peg$silentFails--;\n            if (s6 === peg$FAILED) {\n              s5 = void 0;\n            } else {\n              peg$currPos = s5;\n              s5 = peg$FAILED;\n            }\n            if (s5 !== peg$FAILED) {\n              if (input.length > peg$currPos) {\n                s6 = input.charAt(peg$currPos);\n                peg$currPos++;\n              } else {\n                s6 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c0); }\n              }\n              if (s6 !== peg$FAILED) {\n                s5 = [s5, s6];\n                s4 = s5;\n              } else {\n                peg$currPos = s4;\n                s4 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s4;\n              s4 = peg$FAILED;\n            }\n            if (s4 !== peg$FAILED) {\n              s3 = input.substring(s3, peg$currPos);\n            } else {\n              s3 = s4;\n            }\n          }\n        }\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseBlock_End();\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c11(s1, s2, s3);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseBlock_Start() {\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8;\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 4) === peg$c3) {\n        s1 = peg$c3;\n        peg$currPos += 4;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c4); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse__();\n        if (s2 !== peg$FAILED) {\n          if (input.substr(peg$currPos, 3) === peg$c5) {\n            s3 = peg$c5;\n            peg$currPos += 3;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c6); }\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parseBlock_Name();\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parse__();\n              if (s5 !== peg$FAILED) {\n                s6 = peg$currPos;\n                s7 = peg$parseBlock_Attributes();\n                if (s7 !== peg$FAILED) {\n                  s8 = peg$parse__();\n                  if (s8 !== peg$FAILED) {\n                    peg$savedPos = s6;\n                    s7 = peg$c7(s4, s7);\n                    s6 = s7;\n                  } else {\n                    peg$currPos = s6;\n                    s6 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s6;\n                  s6 = peg$FAILED;\n                }\n                if (s6 === peg$FAILED) {\n                  s6 = null;\n                }\n                if (s6 !== peg$FAILED) {\n                  if (input.substr(peg$currPos, 3) === peg$c12) {\n                    s7 = peg$c12;\n                    peg$currPos += 3;\n                  } else {\n                    s7 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c13); }\n                  }\n                  if (s7 !== peg$FAILED) {\n                    peg$savedPos = s0;\n                    s1 = peg$c14(s4, s6);\n                    s0 = s1;\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseBlock_End() {\n      var s0, s1, s2, s3, s4, s5, s6;\n\n      s0 = peg$currPos;\n      if (input.substr(peg$currPos, 4) === peg$c3) {\n        s1 = peg$c3;\n        peg$currPos += 4;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c4); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse__();\n        if (s2 !== peg$FAILED) {\n          if (input.substr(peg$currPos, 4) === peg$c15) {\n            s3 = peg$c15;\n            peg$currPos += 4;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c16); }\n          }\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parseBlock_Name();\n            if (s4 !== peg$FAILED) {\n              s5 = peg$parse__();\n              if (s5 !== peg$FAILED) {\n                if (input.substr(peg$currPos, 3) === peg$c12) {\n                  s6 = peg$c12;\n                  peg$currPos += 3;\n                } else {\n                  s6 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c13); }\n                }\n                if (s6 !== peg$FAILED) {\n                  peg$savedPos = s0;\n                  s1 = peg$c17(s4);\n                  s0 = s1;\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n    function peg$parseBlock_Name() {\n      var s0;\n\n      s0 = peg$parseNamespaced_Block_Name();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseCore_Block_Name();\n      }\n\n      return s0;\n    }\n\n    function peg$parseNamespaced_Block_Name() {\n      var s0, s1, s2, s3, s4;\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseBlock_Name_Part();\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 47) {\n          s3 = peg$c18;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c19); }\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseBlock_Name_Part();\n          if (s4 !== peg$FAILED) {\n            s2 = [s2, s3, s4];\n            s1 = s2;\n          } else {\n            peg$currPos = s1;\n            s1 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        s0 = input.substring(s0, peg$currPos);\n      } else {\n        s0 = s1;\n      }\n\n      return s0;\n    }\n\n    function peg$parseCore_Block_Name() {\n      var s0, s1, s2;\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parseBlock_Name_Part();\n      if (s2 !== peg$FAILED) {\n        s1 = input.substring(s1, peg$currPos);\n      } else {\n        s1 = s2;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c20(s1);\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parseBlock_Name_Part() {\n      var s0, s1, s2, s3, s4;\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      if (peg$c21.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c22); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = [];\n        if (peg$c23.test(input.charAt(peg$currPos))) {\n          s4 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s4 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c24); }\n        }\n        while (s4 !== peg$FAILED) {\n          s3.push(s4);\n          if (peg$c23.test(input.charAt(peg$currPos))) {\n            s4 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s4 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c24); }\n          }\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        s0 = input.substring(s0, peg$currPos);\n      } else {\n        s0 = s1;\n      }\n\n      return s0;\n    }\n\n    function peg$parseBlock_Attributes() {\n      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12;\n\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 123) {\n        s3 = peg$c25;\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c26); }\n      }\n      if (s3 !== peg$FAILED) {\n        s4 = [];\n        s5 = peg$currPos;\n        s6 = peg$currPos;\n        peg$silentFails++;\n        s7 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 125) {\n          s8 = peg$c27;\n          peg$currPos++;\n        } else {\n          s8 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c28); }\n        }\n        if (s8 !== peg$FAILED) {\n          s9 = peg$parse__();\n          if (s9 !== peg$FAILED) {\n            s10 = peg$c29;\n            if (s10 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 47) {\n                s11 = peg$c18;\n                peg$currPos++;\n              } else {\n                s11 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$c19); }\n              }\n              if (s11 === peg$FAILED) {\n                s11 = null;\n              }\n              if (s11 !== peg$FAILED) {\n                if (input.substr(peg$currPos, 3) === peg$c12) {\n                  s12 = peg$c12;\n                  peg$currPos += 3;\n                } else {\n                  s12 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c13); }\n                }\n                if (s12 !== peg$FAILED) {\n                  s8 = [s8, s9, s10, s11, s12];\n                  s7 = s8;\n                } else {\n                  peg$currPos = s7;\n                  s7 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s7;\n                s7 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s7;\n              s7 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s7;\n            s7 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s7;\n          s7 = peg$FAILED;\n        }\n        peg$silentFails--;\n        if (s7 === peg$FAILED) {\n          s6 = void 0;\n        } else {\n          peg$currPos = s6;\n          s6 = peg$FAILED;\n        }\n        if (s6 !== peg$FAILED) {\n          if (input.length > peg$currPos) {\n            s7 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s7 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c0); }\n          }\n          if (s7 !== peg$FAILED) {\n            s6 = [s6, s7];\n            s5 = s6;\n          } else {\n            peg$currPos = s5;\n            s5 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s5;\n          s5 = peg$FAILED;\n        }\n        while (s5 !== peg$FAILED) {\n          s4.push(s5);\n          s5 = peg$currPos;\n          s6 = peg$currPos;\n          peg$silentFails++;\n          s7 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 125) {\n            s8 = peg$c27;\n            peg$currPos++;\n          } else {\n            s8 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c28); }\n          }\n          if (s8 !== peg$FAILED) {\n            s9 = peg$parse__();\n            if (s9 !== peg$FAILED) {\n              s10 = peg$c29;\n              if (s10 !== peg$FAILED) {\n                if (input.charCodeAt(peg$currPos) === 47) {\n                  s11 = peg$c18;\n                  peg$currPos++;\n                } else {\n                  s11 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$c19); }\n                }\n                if (s11 === peg$FAILED) {\n                  s11 = null;\n                }\n                if (s11 !== peg$FAILED) {\n                  if (input.substr(peg$currPos, 3) === peg$c12) {\n                    s12 = peg$c12;\n                    peg$currPos += 3;\n                  } else {\n                    s12 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$c13); }\n                  }\n                  if (s12 !== peg$FAILED) {\n                    s8 = [s8, s9, s10, s11, s12];\n                    s7 = s8;\n                  } else {\n                    peg$currPos = s7;\n                    s7 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s7;\n                  s7 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s7;\n                s7 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s7;\n              s7 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s7;\n            s7 = peg$FAILED;\n          }\n          peg$silentFails--;\n          if (s7 === peg$FAILED) {\n            s6 = void 0;\n          } else {\n            peg$currPos = s6;\n            s6 = peg$FAILED;\n          }\n          if (s6 !== peg$FAILED) {\n            if (input.length > peg$currPos) {\n              s7 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s7 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c0); }\n            }\n            if (s7 !== peg$FAILED) {\n              s6 = [s6, s7];\n              s5 = s6;\n            } else {\n              peg$currPos = s5;\n              s5 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s5;\n            s5 = peg$FAILED;\n          }\n        }\n        if (s4 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 125) {\n            s5 = peg$c27;\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c28); }\n          }\n          if (s5 !== peg$FAILED) {\n            s3 = [s3, s4, s5];\n            s2 = s3;\n          } else {\n            peg$currPos = s2;\n            s2 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        s1 = input.substring(s1, peg$currPos);\n      } else {\n        s1 = s2;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c30(s1);\n      }\n      s0 = s1;\n\n      return s0;\n    }\n\n    function peg$parse__() {\n      var s0, s1;\n\n      s0 = [];\n      if (peg$c31.test(input.charAt(peg$currPos))) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c32); }\n      }\n      if (s1 !== peg$FAILED) {\n        while (s1 !== peg$FAILED) {\n          s0.push(s1);\n          if (peg$c31.test(input.charAt(peg$currPos))) {\n            s1 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c32); }\n          }\n        }\n      } else {\n        s0 = peg$FAILED;\n      }\n\n      return s0;\n    }\n\n\n\n    /*\n     *\n     *    _____       _             _\n     *   / ____|     | |           | |\n     *  | |  __ _   _| |_ ___ _ __ | |__   ___ _ __ __ _\n     *  | | |_ | | | | __/ _ \\ '_ \\| '_ \\ / _ \\ '__/ _` |\n     *  | |__| | |_| | ||  __/ | | | |_) |  __/ | | (_| |\n     *   \\_____|\\__,_|\\__\\___|_| |_|_.__/ \\___|_|  \\__, |\n     *                                              __/ |\n     *                  GRAMMAR                    |___/\n     *\n     *\n     * Welcome to the grammar file for Gutenberg posts!\n     *\n     * Please don't be distracted by the functions at the top\n     * here - they're just helpers for the grammar below. We\n     * try to keep them as minimal and simple as possible,\n     * but the parser generator forces us to declare them at\n     * the beginning of the file.\n     *\n     * What follows is the official specification grammar for\n     * documents created or edited in Gutenberg. It starts at\n     * the top-level rule `Block_List`\n     *\n     * The grammar is defined by a series of _rules_ and ways\n     * to return matches on those rules. It's a _PEG_, a\n     * parsing expression grammar, which simply means that for\n     * each of our rules we have a set of sub-rules to match\n     * on and the generated parser will try them in order\n     * until it finds the first match.\n     *\n     * This grammar is a _specification_ (with as little actual\n     * code as we can get away with) which is used by the\n     * parser generator to generate the actual _parser_ which\n     * is used by Gutenberg. We generate two parsers: one in\n     * JavaScript for use the browser and one in PHP for\n     * WordPress itself. PEG parser generators are available\n     * in many languages, though different libraries may require\n     * some translation of this grammar into their syntax.\n     *\n     * For more information:\n     * @see https://pegjs.org\n     * @see https://en.wikipedia.org/wiki/Parsing_expression_grammar\n     *\n     */\n\n    /** <?php\n    // The `maybeJSON` function is not needed in PHP because its return semantics\n    // are the same as `json_decode`\n\n    // array arguments are backwards because of PHP\n    if ( ! function_exists( 'peg_array_partition' ) ) {\n        function peg_array_partition( $array, $predicate ) {\n            $truthy = array();\n            $falsey = array();\n\n            foreach ( $array as $item ) {\n                call_user_func( $predicate, $item )\n                    ? $truthy[] = $item\n                    : $falsey[] = $item;\n            }\n\n            return array( $truthy, $falsey );\n        }\n    }\n\n    if ( ! function_exists( 'peg_join_blocks' ) ) {\n        function peg_join_blocks( $pre, $tokens, $post ) {\n            $blocks = array();\n\n            if ( ! empty( $pre ) ) {\n                $blocks[] = array( 'attrs' => array(), 'innerHTML' => $pre );\n            }\n\n            foreach ( $tokens as $token ) {\n                list( $token, $html ) = $token;\n\n                $blocks[] = $token;\n\n                if ( ! empty( $html ) ) {\n                    $blocks[] = array( 'attrs' => array(), 'innerHTML' => $html );\n                }\n            }\n\n            if ( ! empty( $post ) ) {\n                $blocks[] = array( 'attrs' => array(), 'innerHTML' => $post );\n            }\n\n            return $blocks;\n        }\n    }\n\n    ?> **/\n\n    function freeform( s ) {\n        return s.length && {\n            attrs: {},\n            innerHTML: s\n        };\n    }\n\n    function joinBlocks( pre, tokens, post ) {\n        var blocks = [], i, l, html, item, token;\n\n        if ( pre.length ) {\n            blocks.push( freeform( pre ) );\n        }\n\n        for ( i = 0, l = tokens.length; i < l; i++ ) {\n            item = tokens[ i ];\n            token = item[ 0 ];\n            html = item[ 1 ];\n\n            blocks.push( token );\n            if ( html.length ) {\n                blocks.push( freeform( html ) );\n            }\n        }\n\n        if ( post.length ) {\n            blocks.push( freeform( post ) );\n        }\n\n        return blocks;\n    }\n\n    function maybeJSON( s ) {\n        try {\n            return JSON.parse( s );\n        } catch (e) {\n            return null;\n        }\n    }\n\n    function partition( predicate, list ) {\n        var i, l, item;\n        var truthy = [];\n        var falsey = [];\n\n        // nod to performance over a simpler reduce\n        // and clone model we could have taken here\n        for ( i = 0, l = list.length; i < l; i++ ) {\n            item = list[ i ];\n\n            predicate( item )\n                ? truthy.push( item )\n                : falsey.push( item )\n        };\n\n        return [ truthy, falsey ];\n    }\n\n\n\n    peg$result = peg$startRuleFunction();\n\n    if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n      return peg$result;\n    } else {\n      if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n        peg$fail(peg$endExpectation());\n      }\n\n      throw peg$buildStructuredError(\n        peg$maxFailExpected,\n        peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,\n        peg$maxFailPos < input.length\n          ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)\n          : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)\n      );\n    }\n  }\n\n  return peg$parse;\n});\n"
);

document.getElementById( 'post-list-content' ).value = `
https://raw.githubusercontent.com/dmsnell/gutenberg-document-library/master/library/demo-post.html
https://raw.githubusercontent.com/dmsnell/gutenberg-document-library/master/library/shortcode-shortcomings.html
https://raw.githubusercontent.com/dmsnell/gutenberg-document-library/master/library/redesigning-chrome-desktop.html
https://raw.githubusercontent.com/dmsnell/gutenberg-document-library/master/library/web-at-maximum-fps.html
https://raw.githubusercontent.com/dmsnell/gutenberg-document-library/master/library/early-adopting-the-future.html
https://raw.githubusercontent.com/dmsnell/gutenberg-document-library/master/library/pygmalian-raw-html.html
https://raw.githubusercontent.com/dmsnell/gutenberg-document-library/master/library/moby-dick-parsed.html
`;